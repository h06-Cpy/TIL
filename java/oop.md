# OOP
객체: 개발자가 현실 세계에 있는 대상들을 변수처럼 사용하기 위해 만든 추상적인 것

필드: 객체가 가지고 있는 상태, 특징 등을 담는 변수, 흔히 멤버 변수라고 알고 있는 거

메서드: 객체의 동작 등을 표현하는 함수

생성자: 필드를 초기화하기 위해 쓰임

클래스: 객체의 정보를 담고 있는 청사진, 클래스가 붕어빵 틀이라면 객체(인스턴스)가 붕어빵

## 생성자

클래스 이름과 똑같은 이름을 가지고 메서드처럼 생겼지만 **필드 초기화를 담당**하기 떄문에 생성자라 부름

클래스에 public이 붙으면 생성자도 public이 붙음

생성자가 클래스에 직접 명시되어있지 않으면 컴파일러가 소스파일을 바이트 코드로 바꿀때 기본 생성자가 자동 추가 됨

new로 객체를 생성할때 쓰는 것이 바로 생성자

생성자 매개변수랑 필드 이름이랑 같으면 this(자기 참조)를 사용함

---

**생성자 오버로딩**: 객체를 생성할때 생성자 매개변수가 여러개 있으면 경우의 수가 많아짐. 그래서 같은 이름의 생성자를 사용하지만 경우의 수를 나눠서 필드를 초기화함

오버로딩하다보면 반복되는 부분이 생김, 같은 클래서 안에서 다른 생성자를 호출하기 위해 this() 생성자를 사용

## 메서드

클래스 안의 함수

필드와 마찬가지로 클래서 안에서 호출할 때는 그냥 메서드 이름만 사용, 클래서 밖에서 호출할 때는 객체를 생성하고 객체.메서드 형태로 사용

**메서드 오버로딩**: 같은 메서드 이름을 사용하지만 리턴 타입이나 매개변수의 순서, 타입, 개수가 다르도록 할 수 있음, 함수의 기능을 확장하는 것

C++에서는 연산자 오버로딩(+ - * /) 가능 그러나 자바는 불가능, 그나마 String에서 + 가 있음

## Static

정적 멤버: 인스턴스들이 필드값이 똑같고 메서드가 같다면 각 인스턴스마다 필드와 메서드를 가지고 있을 필요가 없음, 그래서 static으로 정적 멤버를 클래스 하나에 만들고 공유함

인스턴스 멤버: static 안붙이면 인스턴스 멤버로, 객체를 생성해야 필드와 메서드 사용 가능

**정적 메서드에서 인스턴스 멤버를 사용하고 싶으면 객체 생성해야 함**

main 메서드도 static이라서 객체 생성하는 거임! 

final: 필드에서 초기값이 저장되면 더이상 수정되지 않음, 객체들의 생성자를 통해 여러가지 값으로 저장할 수 있음

상수: 불변하면서 공유하는 정보, static final type name 순서대로 정의함 ~~C의 #define이 더 편한듯~~

## 접근 제한자

패키지: 폴더 형태이고, 클래스의 일부분으로서 어떤 클래스를 유일하게 만들어주는 식별자 역할

폴더 형태니까 계층적 구조로 클래스를 관리함

---

접근 제한자 종류

- public: 제한 없이 접근, 수정 가능 (클래스,필드,메서드,생성자)
- protected: 같은 패키지 또는 다른 패키지의 자식 클래스에서 접근, 수정 가능(필드,메서드,생성자)
- default: 접근 제한자를 안붙이면 같은 패키지에서만 접근, 수정 가능 (클래스,필드,메서드,생성자)
- private: 모든 외부 클래스에서 접근 불가 (필드,메서드,생성자)

---

singleton(싱글톤): 전체 프로그램에서 단 하나의 객체만 만들도록 보장

싱글톤 패턴: 생성자를 private 접근 제한으로 선언하고 자신의 유일한 객체를 get메서드로 리턴하게 만드는 방법

## 상속

자식 클래스가 부모클래스로부터 필드와 메소드를 받아서 자기의 필드와 메소드도 똑같은 이름으로 존재하는 것, 자식 클래스에 **extends** 붙임

**다중상속 불가**, 오직 부모는 하나

---

자식 객체를 생성하면 부모 객체가 먼저 생성됨

super(): 자식 객체의 생성자 첫줄에 있는 부모 객체의 생성자, 이를 통해 부모 객체로부터 받은 필드를 초기화할 수 있음

## 메소드 재정의(Overriding)

자식 클래스가 부모로부터 받은 메소드를 조금 수정해서 쓸 때 사용

부모 메소드와 동일한 리턴 타입, 메소드 이름, 매개 변수 목록을 가져야 함

접근 제한을 더 강하게 못함, 더 약하게는 가능

새로운 예외를 throws할 수 없음

그럼에도 재정의되지 않은 부모메소드를 사용해야 한다면, super.부모메소드() 사용

## final 키워드

필드에서는 초기값을 넣으면 더이상 수정이 안되는 것이었음

클래스의 경우: 상속할 수 없음, 즉 자식 클래스 없음 ~~대가 끊김~~

메소드의 경우: 재정의 안됨, 즉, 자식 클래스는 부모 메소드 그대로 사용해야 함

## 다형성(Polymorphism)

다형성은 다양한 객체(상속 관계에 있는 객체)를 이용해서 다양한 실행결과가 나오도록 하는 것

자바에서는 **메소드 재정의**와 **타입 변환**으로 다형성을 구현

---

자동 타입 변환: 기본 타입말고 클래스도 타입 변환이 있음, 부모타입 변수 = 자식타입;

자식타입 객체가 부모타입으로 변환됨(상위 타입으로만  됨, 부모타입이 자식타입으로 변환되지 않음)

부모타입으로 변환되었으니 부모타입의 필드와 메소드만 접근 가능, 자식타입 필드 메소드 접근 불가(자식타입 필드 메소드 쓰고 싶으면 강제 타입 변환함, 이때는 예외처리 해줘야 함)

그런데 자식타입에서 메소드 재정의했으면 재정의된 메소드만 접근 가능

이렇게 해서 부모객체지만 재정의된 메소드도 사용할 수 있으니 다양한 결과를 만들어낼 수 있음

---

필드 다형성: 필드에서 부모타입 변수 = 자식타입; 으로 구현

매개변수 다형성: 메소드의 매개변수로 원래 부모타입을 넣어줘야 하지만 자식타입을 넣으므로써 구현

강제 타입 변환할 때 예외처리를 해줘야 하는데 이때 객체 타입을 확인하려면 instanceof 연산자 사용
