# http 헤더2

## 캐시 기본 동작

캐시: 이미지 같이 큰 파일을 클라이언트에 저장해놓고 나중에 갖다 쓰는거, 서버에게 안 받아도 됨

참고) 쿠키: 클라이언트의 인증 정보를 클라이언트에 저장, 세션: 클라이언트의 인증정보를 서버에 저장

---

캐시가 없으면?

만약 서버에게 어떤 파일을 요청한다고 가정, 응답 메시지는 http 헤더 0.1M, 바디 1.0M라고 가정

첫번째 요청에 1.1M를 그대로 받고 클라가 씀

두번째 요청에도 1.1M를 그대로 받고 클라가 씀

문제점: 똑같은 데이터를 느리고 비싼 인터넷 네트워크를 통해 다운로드 받아야 함, 브라우저 로딩 속도 느림, 느린 사용자 경험

---

캐시 쓰면 문제점 해결됨

첫번째 요청에 1.1M 데이터와 유효 시간을 받고 브라우저 캐시에 저장

두번째 요청에는 그냥 캐시에 유효 시간 검증 후 통과되면 갖다 씀 

근데 캐시 시간이 초과되면 어캄? 데이터가 안바뀌어도 또 다운로드 받나?

## 검증 헤더와 조건부 요청

데이터가 바뀌었다면 또 다운로드 받아야 하지만 그게 아니면 캐시꺼 그대로 사용하는게 바람직

캐시 검증하기 위해 서버는 검증 헤더(Validator) 사용 

- Last-Modified: 최종 수정 일(년도, 날짜, 시, 분, 초)로 캐시 검증
    - 1초 미만 단위로 캐시 조정 불가능
- ETag(Entity Tag): 데이터의 버전으로 캐시 검증
    - 캐시용 데이터에 임의의 고유한 버전 이름(해시로 생성)을 달아둠
    - 데이터가 변경되면 이름을 바꿈(해시 다시 생성)

클라이언트는 조건부 요청 헤더 사용해서 서버에게 데이터 바뀌었는지 확인해달라고 함

- If—Match, If-None-Match: ETag 값 사용
- If-Modified-Since, If-Unmodified-Since: Last-Modified 값 사용

---

이제 이것들을 포함한 요청 응답을 살펴보자

Last-Modified의 경우)

1. 첫번째 요청에 1.1M 데이터와 함께 Last-Modified(최종 수정일) 보냄
2. 캐시 시간 초과 한 후 두번째 요청을 하면 조건부 요청(if-modified-since 등)을 보내서 서버에서 최종 수정일 비교
3. 수정되지 않았다면 304 Not Modified 응답을 보냄. 이때 1.0M 짜리 http 바디는 필요없다!(캐시 꺼 쓰면 되니까) 0.1M짜리 헤더만 보내면 됨
4. 클라는 캐시 데이터꺼 쓰고 캐시 유효 시간 갱신됨

근데 데이터를 수정했다 롤백하는 경우도 있음

A→B로 수정했는데 아 아니다 다시 B→A로 바꾸면 최종 수정일은 갱신됐지만 결과적으로 데이터는 똑같음 그래서 ETag 사용

ETag의 경우)

1. 첫번째 요청에 1.1M 데이터와 함께 ETag 보냄
2. 캐시 시간 초과 한 후 두번째 요청을 하면 조건부 요청(If-None-Match 등)을 보내서 서버에서 ETag 비교
3. 수정되지 않았다면 304 Not Modified 응답을 보냄. 이때도 역시 0.1M짜리 헤더만 보내면 됨
4. 클라는 캐시 데이터꺼 쓰고 캐시 유효 시간 갱신됨

## 캐시와 조건부 요청 헤더

- **Cache-Control**: 캐시 지시어로 이걸 가장 많이 씀
    - Cache-Control: max-age → 캐시 유효 시간 클라이언트에게 알려줌, 초 단위
    - Cache-Control: no-cache → 데이터는 캐시 가능한데 항상 원(origin) 서버에 검증해야 함
    - Cache-Control: no-store → 데이터에 민감한 정보가 있어서 저장하면 안됨, 사용 후 빨리 삭제 요망
- Pragma: no-cache → http 1.0 하위 호환이라 옛날 버전에 씀
- expires: Mon, 01 Jan 1990 00:00:00 GMT (하위 호환)
    - 캐시 만료일을 날짜로 지정, http 1.0부터 사용
    - 지금은 더 유연한 초단위 지정인 max-age 권장
    - max-age랑 같이 쓰면 expires 무시

## 프록시 캐시

origin 서버: 원래 소스를 가지고 있는 서버

우리가 미국에 있는 원 서버랑 통신하면 좀 느림. 그래서 중간에 프록시 캐시 서버를 한국에 두고 이를 사용하면 더 빨리 데이터를 이용할 수 있음

웹 브라우저는 private 캐시고, 프록시 캐시 서버는 public 캐시임

---

Cache-Control 기타 모음

- Cache-Control: public → 응답이 public 캐시에 저장되어도 됨
- Cache-Control: private → 응답이 해당 사용자만을 위한 것임(기본값)
- Cache-Control: s-maxage → 프록시 캐시에만 적용되는 max-age
- Age: 60 (HTTP 헤더) → 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)

밑에 두개는 프록시 서버 얘기라 중요하진 않음

## 캐시 무효화

대부분의 데이터는 캐시로 저장되지만 어떤 데이터는 저장 안되길 원할 수 있음(통장 내역 등)

확실한 캐시 무효화 응답

Cache-Control: no-cache, no-store, must-revalidate

Pragma: no-cache

이걸 다 써주면 됨

---

여기서 must-revalidate가 뭔가?

- 캐시 만료 후 최초 조회시 원 서버에 검증
- 원 서버 접근 실패시 반드시 오류 발생해야 함 - 504 Gateway Timeout

no-cache랑 차이점: no-cache만 있으면 프록시 캐시에서 원 서버 접근 실패할 경우 오류 안뜨고 200 OK 뜰 수도 있음(서버 개발자가 오래된 데이터라도 보여주자 해서)

하지만 must-revalidate가 있으면 무조건 오류 뜸

---
출처: 모든 개발자를 위한 HTTP 웹 기본 지식 - 김영한님

https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard
